import java.nio.file.Paths

apply plugin: 'groovy'

sourceSets {
  jobs {
    groovy {
      compileClasspath += main.compileClasspath
    }
  }
}

repositories {
  mavenCentral()
  maven { url 'https://repo.jenkins-ci.org/public/' } // Jenkins plugins repo
}

configurations {
  testPlugins {}

  // The dependencies xalan & xerces alter the tests' results, see JENKINS-45512
  testCompile {
    exclude group: 'xalan'
    exclude group: 'xerces'
  }
}

dependencies {
  // Job DSL core is required to have DSL completion in Job DSL files
  implementation("org.jenkins-ci.plugins:job-dsl-core:${jobDslVersion}") {
    // Exclusion from job-dsl pom, check: https://repo.jenkins-ci.org/public/org/jenkins-ci/plugins/job-dsl
    exclude group: 'org.jvnet.hudson', module: 'xstream'
  }

  // testImplementation 'org.jenkins-ci.tools:gradle-jpi-plugin:0.50.0'

  // Test framework
  testImplementation 'org.spockframework:spock-core:1.3-groovy-2.4'

  // Jenkins test harness dependencies
  testImplementation 'org.jenkins-ci.main:jenkins-test-harness:1912.v0cdf15450b_fb'
  testImplementation "org.jenkins-ci.main:jenkins-war:${jenkinsVersion}"

  // Load plugin jars to make sure the tests have the plugins in the classpath
  testImplementation jenkinsPlugins
    .split(',')
    .collect { [it, "${it}@jar"] }
    .flatten() as List<String>

  // Plugins to install on the test instance (list from gradle.properties)
  // Installation happens in task resolveTestPlugins
  testPlugins jenkinsPlugins
    .split(',') as List<String>
}

class JenkinsPluginMetadata {
  public String name
  public String fileName

  JenkinsPluginMetadata (final String name, final String extension) {
    this.name = name
    this.fileName = "${name}.${extension}"
  }
}

final Map<String, JenkinsPluginMetadata> pluginsMapping = new HashMap<>()

/**
 * Prepare the Jenkins instance so it is as close to the target instance as possible.
 * This means getting the list of installed plugins on the target instance and
 * installing the same set of plugins on the test instance.
 */
tasks.register('resolveTestPlugins', Copy) {
  doFirst {
    // For each plugin, create a mapping name -> JenkinsPluginMetadata
    configurations.testPlugins
      .resolvedConfiguration
      .resolvedArtifacts
      .findAll { it.extension == 'hpi' || it.extension == 'jpi' }
      .each {
        pluginsMapping.put(
          (String) it.file.name,
          new JenkinsPluginMetadata((String) it.name, (String) it.extension)
        )
      }
  }

  // For each mapping created above, store the files in test-dependencies so
  // the Jenkins instance as access to them at runtime.
  from configurations.testPlugins
  into Paths.get(sourceSets.test.output.resourcesDir.toURI())
    .resolve('test-dependencies')
  include '*.hpi'
  include '*.jpi'
  rename { filePath ->
    final String fileName = Paths.get((String) filePath).getFileName()
    return pluginsMapping.get(fileName).fileName
  }

  doLast {
    // Finally, write an index file to tell the Jenkins instance about the plugins to load
    Paths.get(destinationDir.toURI())
      .resolve('index')
      .setText(
        pluginsMapping
          .values()
          .collect { it.name }
          .join('\n'),
        'UTF-8'
      )
  }
}

test {
  jvmArgs '--add-opens=java.base/java.util=ALL-UNNAMED'
  dependsOn tasks.resolveTestPlugins // When the instance is ready
  inputs.files sourceSets.jobs.groovy.srcDirs // Read the Job DSL files from the jobs folder defined in sourceSets
  systemProperty 'buildDirectory', project.buildDir.absolutePath // Set build directory for Jenkins test harness, JENKINS-26331
}
